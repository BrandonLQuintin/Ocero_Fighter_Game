// Load a text resource from a file over the network
var loadTextResource = function (url, callback) {
    var request = new XMLHttpRequest();
    request.open('GET', url, true);
    request.onload = function () {
        if (request.status < 200 || request.status > 299) {
            callback('Error: HTTP Status ' + request.status + ' on resource ' + url);
        } else {
            callback(null, request.responseText);
        }
    };
    request.send();
};

// Load an image from a file over the network
var loadImage = function (url, callback) {
    var image = new Image();
    image.onload = function () {
        callback(null, image);
    };
    image.src = url;
};

// Load a JSON resource from a file over the network
var loadJSONResource = function (url, callback) {
    loadTextResource(url, function (err, result) {
        if (err) {
            callback(err);
        } else {
            try {
                callback(null, JSON.parse(result));
            } catch (e) {
                callback(e);
            }
        }
    });
};


function compileShader(type, source){
	if (type == 'vertex'){
		gl.compileShader(source);
		if (!gl.getShaderParameter(source, gl.COMPILE_STATUS)) {
			console.error('ERROR compiling vertex shader!', gl.getShaderInfoLog(source));
			return;
		}
	}
	else {
		gl.compileShader(source);
		if (!gl.getShaderParameter(source, gl.COMPILE_STATUS)) {
			console.error('ERROR compiling fragment shader!', gl.getShaderInfoLog(source));
			return;
		}
	}
}

function linkProgram(programName){
	gl.linkProgram(programName);
	if (!gl.getProgramParameter(programName, gl.LINK_STATUS)) {
		console.error('ERROR linking program!', gl.getProgramInfoLog(programName));
		return;
	}
	gl.validateProgram(programName);
	if (!gl.getProgramParameter(programName, gl.VALIDATE_STATUS)) {
		console.error('ERROR validating program!', gl.getProgramInfoLog(programName));
		return;
	}
}

function moveToAnotherVertex(vertex1, vertex2, forwardOrBackward, speed){ // I had help from ChatGPT for this one.
    x = vertex1[0];
    y = vertex1[1];
    z = vertex1[2];

    x1 = vertex2[0];
    y1 = vertex2[1];
    z1 = vertex2[2];

    directionX = x1 - x;
    directionY = y1 - y;
    directionZ = z1 - z;

    distance = Math.sqrt(directionX ** 2 + directionY ** 2 + directionZ ** 2);
    normalizedDirectionX = directionX / distance;
    normalizedDirectionY = directionY / distance;
    normalizedDirectionZ = directionZ / distance;
    

    displacementX = normalizedDirectionX * speed;
    displacementY = normalizedDirectionY * speed;
    displacementZ = normalizedDirectionZ * speed;
    
    if (forwardOrBackward == 'forward'){
        newX = x + displacementX;
        newY = y + displacementY;
        newZ = z + displacementZ;
    }
    
    else{
        newX = x - displacementX;
        newY = y - displacementY;
        newZ = z - displacementZ;
    }

    return [newX, newY, newZ];
}

function calculateDistance(vertex1, vertex2){
    x = vertex1[0];
    y = vertex1[1];
    z = vertex1[2];

    x1 = vertex2[0];
    y1 = vertex2[1];
    z1 = vertex2[2];

    directionX = x1 - x;
    directionY = y1 - y;
    directionZ = z1 - z;

    distance = Math.sqrt(directionX ** 2 + directionY ** 2 + directionZ ** 2);
    return distance;
}

function calculateAngle(vertex1, vertex2) { // generated by copilot
     // Extract x and z coordinates from the vertices
     const x1 = vertex1[0];
     const z1 = vertex1[2];
     const x2 = vertex2[0];
     const z2 = vertex2[2];
 
     // Calculate dot product
     const dotProduct = x1 * x2 + z1 * z2;
 
     // Calculate magnitudes of the vectors
     const magnitude1 = Math.sqrt(x1 * x1 + z1 * z1);
     const magnitude2 = Math.sqrt(x2 * x2 + z2 * z2);
 
     // Calculate the cosine of the angle
     const cosAngle = dotProduct / (magnitude1 * magnitude2);
 
     // Ensure the value passed to Math.acos is within the valid range [-1, 1]
     const safeCosAngle = Math.max(-1, Math.min(1, cosAngle));
 
     // Convert the cosine value to radians
     const angleInRadians = Math.acos(safeCosAngle);
 
     // Convert the angle to degrees
     const angleInDegrees = (angleInRadians * 180) / Math.PI;
 
     return angleInDegrees;
 }


function rotateObjectAroundAxis(vertex1, vertex2, angle) { // I had help from ChatGPT for this one.
    x = vertex1[0];
    y = vertex1[1];
    z = vertex1[2];

    x1 = vertex2[0];
    y1 = vertex2[1];
    z1 = vertex2[2];

    displacement = [
        x - x1,
        y - y1,
        z - z1
    ];

    newX = x1 + displacement[0] * Math.cos(angle) - displacement[2] * Math.sin(angle);
    newY = y;
    newZ = z1 + displacement[0] * Math.sin(angle) + displacement[2] * Math.cos(angle);

    return [newX, newY, newZ];
}

function returnAtlasUV(x, y){
    // assuming the texture is a 12x12 grid.
    // if selecting grid (1, 1), type in (0, 0) instead.
    gridsize = 12;
    gridlength = 1 / gridsize;

    vEnd = 1 - (y * gridlength);
    vStart = vEnd - gridlength;
    
    uStart = x * gridlength;
    uEnd = uStart + gridlength;
    
    
    return [uStart, vStart, uEnd, vEnd];
}

calculateSpriteIndex = function(angle){
    if (angle < .7875 && angle > -.7875) {
        spriteIndex = 0; // back view
    } else if (angle < 2.7125 && angle < -2.0125) {
        spriteIndex = 2; // front view
    }
     else if (angle < -.7875) {
        spriteIndex = 1; // right view
    } else {
        spriteIndex = 3; // left view
    }

    return spriteIndex;
}

generateRandomCoordinates = function(vertex){
    x = vertex[0];
    y = vertex[1];
    z = vertex[2];

    newX = x + (Math.random() * 20 - 10);
    newY = y + (Math.random() * 20 - 10);
    if (newY < 0){
        newY = 0;
    }
    if (newY > 10){
        newY = 10;
    }
    newZ = z + (Math.random() * 20 - 10);

    return [newX, newY, newZ];
}